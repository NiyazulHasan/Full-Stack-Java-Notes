Thread priority
==================
In java, every thread has a priority automatically generated by JVM or explicitly provided by the programmer.

The valid range for thread priority is 1 to 10.1 is a least priority and 10 is a highest priority.

Thread class defines following standard constants as thread priorities.
ex:
	Thread.MAX_PRIORITY    -- 10
	Thread.NORM_PRIORITY   -- 5
	Thread.MIN_PRIORITY    -- 1

We don't have such constants like HIGH_PRIORITY or LOW_PRIORITY.

A thread which is having highest priority will be executed first.

Thread schedular uses thread priority while allocating CPU.

If multiple threads having same priority then we can't expect any execution order.

We have following methods to set and get the thread priority.
ex:
	public final void setPriority(int piority)
	public final int getPriority()

If we take more then 10 priority then we will get IllegalArgumentException.

ex:
----
class  MyThread extends Thread
{
	
}
class Test 
{
	public static void main(String[] args)
	{
		System.out.println(Thread.currentThread().getPriority());//5	

		MyThread t=new MyThread();
		System.out.println(t.getPriority());//5

		Thread.currentThread().setPriority(9);
		System.out.println(Thread.currentThread().getPriority());//9
		System.out.println(t.getPriority());//5

		t.setPriority(4);
		System.out.println(t.getPriority());//4

		t.setPriority(11); // R.E IllegalArgumentException
	}
}

Setting and Getting Name of a thread
=====================================
In java, every thread has a name automatically generated by JVM or explictly provided by the programmer.

We have following methods to set and get name of a thread.
ex:
	public final void setName(String name)
	public final String getName()

ex:
---
class  MyThread extends Thread
{
	
}
class Test 
{
	public static void main(String[] args)
	{
		System.out.println(Thread.currentThread().getName());//main 
		
		MyThread t=new MyThread(); 
		System.out.println(t.getName());//Thread-0

		Thread.currentThread().setName("Parent-Thread");
		System.out.println(Thread.currentThread().getName());//Parent-Thread

		t.setName("Child-Thread");
		System.out.println(t.getName());//Child-Thread
	}
}

In how many ways we can prevent a thread from execution
======================================================
There are three ways to prevent(stop) a thread from execution.

1)yield()

2)join()

3)sleep()
 

1)yield()
-----------
It will pause the current execution thread and gives chance to other threads having same priority.

If multiple threads having same priority then we can't expect any execution order.

If there is no waiting threads then same thread will continue the execution.

ex:
	public static native void yield()

Diagram: java42.1

ex:
--
class  MyThread extends Thread
{
	public void run()
	{
		for(int i=1;i<=5;i++)
		{
			System.out.println("Child-Thread");
		}
	}
}
class Test 
{
	public static void main(String[] args)
	{
		MyThread t=new MyThread();
		t.start();
		for(int i=1;i<=5;i++)
		{
			Thread.currentThread().yield();
			System.out.println("Parent-Thread");
		}
	}
}


 
2)join()
------------
If a thread wants to wait untill the completion of some other thread then we need to use join() method.

A join() method throws one checked exception called InterruptedException so we must and should handle that exception by using try and catch block or by using throws statement.

ex:
	public final void join()throws InterruptedException
	public final void join(long ms)throws InterruptedException	
	public final void join(long ms,int ns)throws InterruptedException

Diagram: java42.2

ex:
-----
class  MyThread extends Thread
{
	public void run()
	{
		for(int i=1;i<=5;i++)
		{
			System.out.println("Child-Thread");
		}
	}
}
class Test 
{
	public static void main(String[] args)throws InterruptedException
	{
		MyThread t=new MyThread();
		t.start();
		t.join();
		for(int i=1;i<=5;i++)
		{
			System.out.println("Parent-Thread");
		}
	}
}

3)sleep()
-------------
If a thread don't want to perform any operation on perticular amount of time then we need to use sleep() method.

A sleep() method will throw one checked exception called InterruptedException so must and should handle that exception by using try and catch block or by using throws statement.

ex:
	public static native void sleep()throws InterruptedException
 	public static native void sleep(long ms)throws InterruptedException
	public static native void sleep(long ms,int ns)throws InterruptedException

Diagram: java42.3

ex:
---
class  MyThread extends Thread
{
	public void run()
	{
		for(int i=1;i<=5;i++)
		{
			System.out.println("Child-Thread");
			try
			{
				Thread.sleep(2000);
			}
			catch (InterruptedException ie)
			{
				ie.printStackTrace();
			}
		}
	}
}
class Test 
{
	public static void main(String[] args)
	{
		MyThread t=new MyThread();
		t.start();
		for(int i=1;i<=5;i++)
		{
			System.out.println("Parent-Thread");
		}
	}
}

Lock Mechanism in Java
=========================
synchronization is build around an entity called lock.

Whenever a thread wants to access any object.First it has to acquire the lock of it and release the lock once thread complete its task.
 

Daemon Thread
=================
Deamon thread is a service provide thread which provides service to user threads.

The life of deamon thread is same as user threads.Once threads executed deamon thread will terminate automatically.

There are many daemon thread are running in our system.
ex:
	Garbage collector , Finalizer  and etc.

To start a deamon thread we need to use setDaemon(true) method.

To check a thread is a daemon or not we need to use isDaemon() method.

ex:

class  MyThread extends Thread
{
	public void run()
	{
		for(int i=1;i<=5;i++)
		{
			System.out.println(Thread.currentThread().isDaemon());
			System.out.println("Child-Thread");
		}
	}
}
class Test 
{
	public static void main(String[] args)
	{
		MyThread t=new MyThread();
		t.setDaemon(true);
		t.start();
		for(int i=1;i<=5;i++)
		{
			System.out.println("Parent-Thread");
		}
	}
}


 





















































































 



































